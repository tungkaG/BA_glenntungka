# # Environemnt parameters
# map_yaml_filename: 'config_FTM_Halle.yaml'            # Map configuration file name (has to be inside src/mpc/maps/)
# odom_topic: '/pf/pose/odom'                           # Topic where the odometry is published

# # MPC prediction paramter
# t: 6                                                  # Prediction horizon                          
# n_batch: 1                                            # Batch size for solving the optimization problem          
# lqr_iter: 5                                           # Number of maximum LQR iterations to solve the differentiable MPC problem
# verbose_mpc: false                                    # Verbosity of the MPC solver       
# goal_weight_x: 13.5                                   # Weight for the x deviation in the cost function
# goal_weight_y: 13.5                                   # Weight for the y deviation in the cost function
# goal_weight_v: 5.5                                    # Weight for the velocity deviation in the cost function
# goal_weight_theta: 13.0                               # Weight for the yaw deviation in the cost function
# ctrl_penalty_a: 0.01                                  # Penalty for the acceleration in the cost function
# ctrl_penalty_steer: 100                               # Penalty for the steering angle in the cost function

# n_ind_search: 5                                       # Number of search index used to calculate the nearest waypoint in planned trajectorie
# dt: 0.10                                              # Disrete Time step
# dl: 0.18                                               # Discrete distance step used to calculate reference path
# varying_dl: true                                     # Varying distance step size
# dl_factor_num: 0.03                                   # Empirical value dl = dl + v * dl_factor_num/dl_factor_denom
# dl_factor_denom: 2.5                                  # Empirical value dl = dl + v * dl_factor_num/dl_factor_denom
# control_frequency: 10                                 # Control frequency: for every x odom messages, the controller is called

# # Vehicle parameters
# wheelbase: 0.3302                                     # Wheelbase of the vehicle in m
# max_steer: 24.0                                       # Maximum steering angle in degrees
# max_speed: 3                                       # Maximum speed of the vehicle in m/s
# min_speed: 0                                          # Minimum speed of the vehicle in m/s
# max_accel: 2.5                                        # Maximum acceleration of the vehicle in m/s^2
# speed_factor: 1                                       # Speed factor for the MPC controller: published speed = SPEED_FACTOR * speed

#############################################################################################################

# Environemnt parameters
map_yaml_filename: 'config_FTM_Halle.yaml'
odom_topic: '/ego_racecar/odom'

# MPC prediction paramter
t: 6
n_batch: 1
lqr_iter: 5
verbose_mpc: false
goal_weight_x: 20.5
goal_weight_y: 20.5
goal_weight_v: 5.5
goal_weight_theta: 13.0
ctrl_penalty_a: 0.01
ctrl_penalty_steer: 100

n_ind_search: 5
dt: 0.10
dl: 0.1
varying_dl: true
dl_factor_num: 0.15
dl_factor_denom: 2.5
control_frequency: 7

# Vehicle parameters
wheelbase: 0.3302
max_steer: 24.0 # degrees
max_speed: 3.5
min_speed: 0
max_accel: 3
speed_factor: 1

############################################################################################################

# if ODOM_TOPIC == '/pf/pose/odom':
#     # System config
#     NX = 4          # state vector: z = [x, y, v, yaw]
#     NU = 2          # input vector: u = [accel, steer]
#     T = 10           # finite time horizon length
#     N_BATCH = 1
#     LQR_ITER = 5
#     VERBOSE_MPC = False

#     # define P during runtime
#     GOAL_WEIGHTS = torch.tensor((26.5, 26.5, 5.5, 26.0), dtype=torch.float32)  # nx
#     CTRL_PENALTY = torch.tensor((0.01, 100), dtype=torch.float32) # nu
#     q = torch.cat((GOAL_WEIGHTS, CTRL_PENALTY))  # nx + nu
#     Q = torch.diag(q).repeat(T, N_BATCH, 1, 1)  # T x B x nx+nu x nx+nu


#     # Vehicle parameters
#     WB = 0.3302                           # Wheelbase [m]
#     MAX_STEER = np.deg2rad(24.0)        # maximum steering angle [rad]
#     MAX_SPEED = 2.9                    # maximum speed [m/s]
#     MIN_SPEED = 0                       # minimum backward speed [m/s]
#     MAX_ACCEL = 2.5                     # maximum acceleration [m/s]
#     SPEED_FACTOR = 1                 # published speed = SPEED_FACTOR * speed

#     # MPC prediction paramter
#     N_IND_SEARCH = 5                        # Search index number
#     DT = 0.10                               # time step [s]
#     dl = 0.25                               # dist step [m]
#     VARYING_DL = False                       # varying distance step size
#     DL_FACTOR = 0.05/3.5                      # empirical value dl = dl + v * factor
#     MAX_DIST = 50.0                          # max allowed distance between previous waypoint and target

#     ########### NOTES ############
#     # 1st turn optimal value for dl_mod = 1.7, using speed factor 0.93
#     # 2nd turn optimal value for dl_mod = ...
#     ########### NOTES ############

#     U_LOWER = torch.tensor([[-np.inf, -MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu
#     U_UPPER = torch.tensor([[MAX_ACCEL, MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu

# if ODOM_TOPIC == '/ego_racecar/odom':
#     # System config
#     NX = 4          # state vector: z = [x, y, v, yaw]
#     NU = 2          # input vector: u = [accel, steer]
#     T = 10           # finite time horizon length
#     N_BATCH = 1
#     LQR_ITER = 5
#     VERBOSE_MPC = False

#     # define P during runtime
#     GOAL_WEIGHTS = torch.tensor((13.5, 13.5, 5.5, 13.0), dtype=torch.float32)  # nx
#     CTRL_PENALTY = torch.tensor((0.01, 100), dtype=torch.float32) # nu
#     q = torch.cat((GOAL_WEIGHTS, CTRL_PENALTY))  # nx + nu
#     Q = torch.diag(q).repeat(T, N_BATCH, 1, 1)  # T x B x nx+nu x nx+nu

#     # MPC prediction paramter
#     N_IND_SEARCH = 5                        # Search index number
#     DT = 0.10                               # time step [s]
#     dl = 0.2                               # dist step [m]
#     DL_FACTOR = 0.1/2.5
#     VARYING_DL = True
#     MAX_DIST = 1000.0                          # max allowed distance between previous waypoint and target

#     # Vehicle parameters
#     WB = 0.3302                           # Wheelbase [m]
#     MAX_STEER = np.deg2rad(24.0)        # maximum steering angle [rad]
#     MAX_SPEED = 3.5                    # maximum speed [m/s]
#     MIN_SPEED = 0                       # minimum backward speed [m/s]
#     MAX_ACCEL = 3                     # maximum acceleration [m/ss]
#     SPEED_FACTOR = 1                    # Speed factor for the MPC controller

#     U_LOWER = torch.tensor([[-np.inf, -MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu
#     U_UPPER = torch.tensor([[MAX_ACCEL, MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu
################################################## Controller Paramter ##################################################

################################################## Controller Paramter BEFORE ##################################################
# # System config
# NX = 4          # state vector: z = [x, y, v, yaw]
# NU = 2          # input vector: u = [accel, steer]
# T = 10           # finite time horizon length
# N_BATCH = 1
# LQR_ITER = 5

# # define P during runtime
# GOAL_WEIGHTS = torch.tensor((13.5, 13.5, 5.5, 13.0), dtype=torch.float32)  # nx
# CTRL_PENALTY = torch.tensor((0.01, 100), dtype=torch.float32) # nu
# q = torch.cat((GOAL_WEIGHTS, CTRL_PENALTY))  # nx + nu
# Q = torch.diag(q).repeat(T, N_BATCH, 1, 1)  # T x B x nx+nu x nx+nu

# # MPC prediction paramter
# N_IND_SEARCH = 5                        # Search index number
# DT = 0.10                               # time step [s]
# dl = 0.20                               # dist step [m]

# # Vehicle parameters
# WB = 0.3302                           # Wheelbase [m]
# MAX_STEER = np.deg2rad(24.0)        # maximum steering angle [rad]
# MAX_SPEED = 2.9                    # maximum speed [m/s]
# MIN_SPEED = 0                       # minimum backward speed [m/s]
# MAX_ACCEL = 2.5                     # maximum acceleration [m/s]
# SPEED_FACTOR = 0.93                  # published speed = SPEED_FACTOR * speed

# U_LOWER = torch.tensor([[-np.inf, -MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu
# U_UPPER = torch.tensor([[MAX_ACCEL, MAX_STEER]], dtype=torch.float32).repeat(T, N_BATCH, 1)  # T x B x nu
################################################## Controller Paramter BEFORE ##################################################